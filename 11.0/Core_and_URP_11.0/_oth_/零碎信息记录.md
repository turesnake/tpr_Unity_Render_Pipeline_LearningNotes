# ================================================================ #
#                      零碎信息记录
# ================================================================ #


# ---------------------------------- #
#   RenderPipelineAsset 实例是谁
访问: "UniversalRenderPipelineAsset" class, 全局唯一的 "RenderPipelineAsset" 派生类

# ---------------------------------- #
#   RenderPipeline  实例是谁
访问: "UniversalRenderPipeline" class, 全局唯一的 "RenderPipeline" 派生类

# ---------------------------------- #
#   RenderPipelineAsset 窗口的编辑界面由谁控制:

class UniversalRenderPipelineAssetEditor;


# ---------------------------------- #
#   material inspector 窗口由谁来布局 ?
如果绑定的是 Lit shader, 那么可访问 "LitGUI" class, 它负责此工作;


# ---------------------------------- #
# asset
位于:
UniversalRenderPipeline__RR_2 中
是个 static property;



# ---------------------------------- #
#  screen space shadow

"UniversalRenderPipeline.InitializeShadowData()" 的官方注释中明确表示,
urp 不再使用 screen space shadow;

同时在 "ShadowData" struct 的注释中也明确表示:
    this feature was replaced by new 'ScreenSpaceShadows' renderer feature"


# ---------------------------------- #
#   "offscreen"
有点迷, 先收集有限的信息:

# -1- "ForwardRenderer.Setup()" 中:
    此处的意思为:
        如果 camera 指定了 render target, 而不是直接渲染进 screen, 就叫做 "offscreen"



# ---------------------------------- #
#   GetShadowTransform()
和 catlike 中的 "ConvertToAtlasMatrix()" 存在一点出入,
缺少了一步运算, 这一步运算, 在 urp 中, 最后是怎么补上的 ?


# ---------------------------------- #
#     "depth surface"
一般指 color render texture 的 depth 部分; 





# ======================================== #
#    urp 中出现的 通用算法
# ======================================== #

# AdditionalLightsShadowCasterPass.InsertionSort();
双指针算法




# ======================================== #
#  迷一样的 "BuiltinRenderTextureType.CameraTarget"
# ======================================== #
信息很零散:

# --- 如果 一个 depth Attachment 表明自己绑定的是 "BuiltinRenderTextureType.CameraTarget",
往往说明, depth 会被存储在 color rt 的 "depth surface" 区域中;



# ======================================== #
#  "_CameraDepthAttachment" 和 "_CameraDepthTexture"
# ======================================== #

    如果一个 render pass 不定义自己的 render target, 那就要沿用 forwardRenderer 的,
    在有些情况下, forwardRenderer 会将 depth target 设置为 "_CameraDepthAttachment",
    比如在 常规 不透明物体 的渲染中;
    它们的 depth 都将被写入 这个 rt 中;
    ---
    这样一切就都说得通了;



# "_CameraDepthAttachment":
这是一个 render texture;



# "_CameraDepthTexture":
这是一个 shader Global Texture

    大部分 pass 都使用的数据

    

# DepthOnlyPass:
    在 "BeforeRenderingPrePasses" 时刻, 将 camera 视野中不透明物的 depth 信息, 写入 rt: "_CameraDepthTexture";


# CopyDepthPass:
    在 "AfterRenderingSkybox" 时刻, 将 "_CameraDepthAttachment" 中的 depth 数据复制到 "_CameraDepthTexture" 中去;






# ======================================== #
#  最复杂的函数: ScriptableRenderer.SetRenderPassAttachments()
# ======================================== #








